
// Breakout_Game.cpp : This file contains the 'main' function. Program execution begins and ends there.
// Julien Merceron - 2023
// code generated by chatGPT
/*
ChatGPT Dec 15th 2022 Version
https://chat.openai.com/chat
*/
/*
SDL
https://github.com/libsdl-org/SDL/releases/tag/release-2.26.2
SDL2-devel-2.26.2-VC.zip
sdl/include
sdl/lib
wrt dlls, ...
... copy \SDL2\lib\x64\SDL2.dll to C:\Windows\System32
... and \SDL2\lib\x86\SDL2.dll to C:\Windows\SysWOW64. Voila
*/
/*
add include path to SDL in VC++ Directories
add lib path to SDL in VC++ Directories
add sdl2.lib in libs to link in Linker -> Input
change from console to windows in Linker -> System
*/
/*
PROMPT MODIFIERS
resolution_driven
add_comments
*/

#include <iostream>
#include "sdl.h"
#include <windows.h>
#include <vector>


// Screen dimensions (as percentages of the actual screen dimensions)
const int SCREEN_WIDTH_PERCENT = 80;
const int SCREEN_HEIGHT_PERCENT = 80;


// Paddle class
class Paddle {
public:
    int x, y;
    int width, height;
    int velocity;

    void update(int screen_width)
    {
        // Check if the player collides with the left or right walls
        if (x < 0 && velocity < 0)
        {
            velocity = 0;
        }
        if (x + width > screen_width && velocity > 0)
        {
            velocity = 0;
        }

        // Update player position based on velocity
        x += velocity;
    }
};
Paddle paddle;

// Ball class
class Ball {
public:
    int x, y;
    int radius;
    int velocityX, velocityY;

    void update(int width, int height) 
    {
        // Update ball position based on velocity
        x += velocityX;
        y += velocityY;

        // Check if the ball collides with the left or right wall
        if (x - radius < 0 || x + radius > width) 
        {
            velocityX *= -1;
        }

        // Check if the ball collides with the top wall or bottom wall
        if (y - radius < 0 || y + radius > height)
        {
            velocityY *= -1;
        }

        // Check if the ball collides with the paddle
        if (y + radius > paddle.y && x > paddle.x && x < paddle.x + paddle.width) 
        {
            velocityY *= -1;
        }
    }
};
Ball ball;

// Block class
class Block {
public:
    int x, y;
    int width, height;
    bool destroyed;

    void update() 
    {
        // Update block state (e.g. check for destruction)
        // Check if the ball collides with the block
        if (ball.x > x && ball.x < x + width && ball.y > y && ball.y < y + height) {
            // If so, mark the block as destroyed
            destroyed = true;
        }
    }
};
std::vector<Block> blocks;

int screen_width, screen_height; 
int game_screen_width;
int game_screen_height;


void fn_vInitObjectsSizeOnScreen()
{
    // Create the paddle
    paddle.x = game_screen_width / 2;
    paddle.y = game_screen_height - game_screen_height / 9;
    paddle.width = game_screen_width / 6;
    paddle.height = game_screen_height / 24;
    paddle.velocity = 0;

    // Create the ball
    ball.x = game_screen_width / 2;
    ball.y = game_screen_height / 2;
    ball.radius = game_screen_height / 48;
    ball.velocityX = 1;
    ball.velocityY = 1;

    // Create the blocks
    for (int i = 0; i < 12; i++) {
        for (int j = 2; j < 6; j++) {
            Block block;
            block.x = i * (game_screen_width / 12);
            block.y = j * (game_screen_height / 18);
            block.width = (game_screen_width / 12);
            block.height = (game_screen_height / 18);
            block.destroyed = false;
            blocks.push_back(block);
        }
    }
}

void fn_vUpdateObjectsSizeOnScreen()
{
    // update the Paddle size on screen
    paddle.x = game_screen_width / 2;
    paddle.y = game_screen_height - game_screen_height / 9;
    paddle.width = game_screen_width / 6;
    paddle.height = game_screen_height / 24;
    //paddle.velocity = 0;

    // update the Ball size on screen
    ball.x = game_screen_width / 2;
    ball.y = game_screen_height / 2;
    ball.radius = game_screen_height / 48;
    //ball.velocityX = 1;
    //ball.velocityY = 1;

    // update the blocks size on screen
    int k = 0;
    for (int i = 0; i < 12; i++) {
        for (int j = 2; j < 6; j++) {
            blocks[k].x = i * (game_screen_width / 12);
            blocks[k].y = j * (game_screen_height / 18);
            blocks[k].width = (game_screen_width / 12);
            blocks[k].height = (game_screen_height / 18);
            k++;
        }
    }
}


int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, PSTR cmdline, int cmdshow)
{

#if 0
    std::cout << "Hello World!\n";
    return 0;
#else
    // Initialize SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0)
    {
        std::cout << "SDL could not initialize! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Flag to track whether the window is in full screen mode
    bool fullScreen = false;

    // Get the actual screen dimensions
    SDL_DisplayMode displayMode;

    // SDL_GetCurrentDisplayMode(0, &screen_width, &screen_height);
    if (SDL_GetCurrentDisplayMode(0, &displayMode) == 0)
    {
        // Success! The current display mode is stored in the "displayMode" variable
        screen_width = displayMode.w;
        screen_height = displayMode.h;
        std::cout << "Success! The current display mode is stored in the displayMode variable, and we have " << screen_width << ", " << screen_height << std::endl;
    }
    else
    {
        // An error occurred. You can use SDL_GetError() to get the error message.
        std::cout << "An error occurred. You can use SDL_GetError() to get the error message" << std::endl;
        return -1;
    }

    // Calculate the dimensions of the game screen (as pixels)
    game_screen_width = screen_width * SCREEN_WIDTH_PERCENT / 100;
    game_screen_height = screen_height * SCREEN_HEIGHT_PERCENT / 100;

    // Create the window
    SDL_Window* window = SDL_CreateWindow("Breakout", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, game_screen_width, game_screen_height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);
    if (window == NULL)
    {
        std::cout << "Window could not be created! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Create the renderer
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL)
    {
        std::cout << "Renderer could not be created! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Init Game Objects
    fn_vInitObjectsSizeOnScreen();



    // Set the frame rate
    const int FPS = 60;
    const int frameDelay = 1000 / FPS;

    // Game loop
    bool running = true;
    while (running) 
    {
        // Handle input
    

        // Handle events
        SDL_Event event;
        while (SDL_PollEvent(&event))
        {
            if (event.type == SDL_QUIT)
            {
                running = false;
            }
            if (event.type == SDL_WINDOWEVENT)
            {
                if (event.window.event == SDL_WINDOWEVENT_RESIZED)
                {
                    // Handle window resized event
                    game_screen_width = event.window.data1;
                    game_screen_height = event.window.data2;
                    // Do something with newWidth and newHeight
                    fn_vUpdateObjectsSizeOnScreen();

                }
            }
            if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_f)
            {
                // Toggle full screen mode
                fullScreen = !fullScreen;
                SDL_SetWindowFullscreen(window, fullScreen ? SDL_WINDOW_FULLSCREEN_DESKTOP : 0);
            }
            if (event.type == SDL_KEYDOWN) 
            {
                if (event.key.keysym.sym == SDLK_LEFT) 
                {
                    paddle.velocity = -5;
                }
                else if (event.key.keysym.sym == SDLK_RIGHT) 
                {
                    paddle.velocity = 5;
                }
            }
            else if (event.type == SDL_KEYUP) 
            {
                if (event.key.keysym.sym == SDLK_LEFT || event.key.keysym.sym == SDLK_RIGHT) 
                {
                    paddle.velocity = 0;
                }
            }
        }

        // Update game state
        paddle.update(game_screen_width);
        ball.update(game_screen_width, game_screen_height);
        for (unsigned int i = 0; i < blocks.size(); i++) 
        {
            blocks[i].update();
        }

        // Set the rendering color
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

        // Clear the window
        SDL_RenderClear(renderer);

        // Draw the paddle
        SDL_Rect paddleRect = { paddle.x, paddle.y, paddle.width, paddle.height };
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderFillRect(renderer, &paddleRect);

        // Draw the ball
        SDL_Rect ballRect = { ball.x - ball.radius, ball.y - ball.radius, ball.radius * 2, ball.radius * 2 };
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderFillRect(renderer, &ballRect);

        // Draw the blocks
        for (unsigned int i = 0; i < blocks.size(); i++)
        {
            if (!blocks[i].destroyed)
            {
                SDL_Rect blockRect = { blocks[i].x, blocks[i].y, blocks[i].width, blocks[i].height };
                SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
                SDL_RenderFillRect(renderer, &blockRect);
            }
        }

        // Display the window
        SDL_RenderPresent(renderer);

        // Delay to achieve desired frame rate
        SDL_Delay(frameDelay);
    }

    // Clean up SDL
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
#endif
}




// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file


